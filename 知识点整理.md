# 一、算法分析基础知识 

## 记号

$$
f(n) = 10n^2 + 5n \\
g(n) = 2^n \\
$$

- $O$：**最坏情况**，函数复杂度小于等于
    $$
    f(n) = O(n^2) \\
    f(n) = O(f(n))
    $$

- $\Omega$：**最优情况**，复杂度大于等于

- $\Theta$：**精确情况**，复杂度等于

    当上界和下界相等时，用 $\Theta$ 来描述算法的复杂度

## 复杂度分析：主定理

### 公式

$$
T(n) = a T(\frac{n}{b}) + f(n), \quad a \geq 1, b > 1
$$

1. 若存在 $\epsilon > 0$，$f(n) = \Large O(n^{\log_b(a) - \epsilon})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)})$
2. 如果 $f(n) = \Large \Theta(n^{\log_b(a)})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)} \cdot \log(n))$
3. 若存在 $\epsilon > 0$，$f(n) = \Large \Omega(n^{\log_b(a) + \epsilon})$，并且存在常数 $c < 1$ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$，则 $T(n) = \Theta(f(n))$

### 分析

- 每个问题会分成 $a$ 个子问题
- 问题可以划分 $\Large log_b n$ 次，每次划分都伴随着 $f(n)$
- 对应到递归树中，最终叶子节点的复杂度是 $\Theta(1)$，共有 $\Large a^{log_b n}$ 个叶子节点，应用换底公式可得 $\Large a^{log_b n} = n^{log_b a}$
- 问题可以简化为 $T(n) = p f(n) + \Large n^{log_b a}$
- 求复杂度等价于比较**处理所有叶子节点**更耗时还是**处理所有划分**更耗时
- 第三种情况中为什么多了：存在常数 $ c < 1 $ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  
    - 每次划分后 $f(n)$ 并不会保持不变，而是会跟着划分 $\large af(\frac{n}{b})$
    - $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  要求 $f(n)$ 划分的复杂度不能大于问题本身，否则没必要分治

### 参考文献

- [深入浅出理解主定理原理(Master theorem)如何计算递归时间复杂度](https://blog.restkhz.com/post/how-master-theorem-works)
- [Wiki 主定理](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86)

## 复杂度分析：递归方程

某递归算法的时间复杂度 $T(n)$ 满足递归方程： $T(n) = 2T(n/2) + bn$ ($n \geq 2$) 且 $T(1) = a$，其中 $n = 2^k$，$a, b, k$ 均为正整数。$T(n)$ 可用 $\Theta$ 表示为

- 展开法
    $$
    \begin{align*}
    T(n) &= 2T\left(\frac{n}{2}\right) + bn \\
         &= 2\left(2T\left(\frac{n}{4}\right) + \frac{1}{2}bn\right) + bn \\
         &= 4T\left(\frac{n}{4}\right) + 2bn \\
         &= 2^k T\left(\frac{n}{2^k}\right) + kbn \\
    \end{align*}
    $$
    
    $$
    n = 2^k, k=log_2 n
    $$

    $$
    \begin{align*}
    T(n) &= 2^k T(1) + kbn \\
         &= an + bn \cdot \log n \\
         &= \Theta(n log n)
    \end{align*}
    $$
    
- 主定理
    $$
    a = 2, b = 2, f(n) = bn
    $$

    $$
    f(n) = \Theta(\large n^{log_b a}) = \Theta(n)
    $$

    $$
    T(n) = \Theta(n log n)
    $$

## 复杂度分析：代码段

![image-20241211150958777](知识点整理.assets/image-20241211150958777.png)

设上述算法中元素比较的最多次数为 $T(n)$，则满足递归方程 $T(n) = T(n-1) + n -1$，$T(1) = T(0) = 0$
$$
\begin{align*}
T(n) &= T(n-1) + n - 1 \\
     &= T(n-2) + (n-2) + (n-1) \\
     &= T(n-3) + (n-3) + (n-2) + (n-1) \\
     &= T(n-k) + kn - \frac{k(k+1)}{2} \\
     &= T(1) + n(n-1) - \frac{n(n-1)}{2} \\
     &= \frac{1}{2} n(n-1) \\
     &= \Theta(n^2)
\end{align*}
$$

## 复杂度分析：图的 DFS

假设图 $G=\big <V, E \big >$ 用**邻接矩阵**表示， $n=|V|, m=|E|$。分析图的深度优先遍历算法 DFS 的时间复杂度。

1. 算法 DFS 中有哪些基本操作？各基本操作耗费时间是多少？

    算法 DFS 中基本操作包括：访问结点、访问相邻结点

    图中每个结点都恰好访问 1 次，访问结点的总次数为 n，耗费时间为 $\Theta(n)$；

    访问相邻节点即扫描邻接矩阵的一行，因此检测总耗费时间为 $\Theta(n^2)$

2. 请根据基本操作的耗费时间，分析得出算法 DFS 的时间复杂度。

    算法 DFS 的时间复杂度主要由访问结点的时间、访问相邻结点的时间来决定，其他运算耗费时间不超过这两部的耗费时间。

    故算法 DFS 时间复杂度为 $\Theta(n) + \Theta(n^2) = \Theta(n^2)$。

# 二、算法设计基本方法

## 例题：找到数组中最大的两个元素

假定 $n=2^k$（k 为正整数）。设计一个分治算法在数组 $A[1..n]$ 中找最大元素和第二大元素， 要求比较次数为 $\frac{3n}{2}-2$

### 分析

1.   用文字简要描述递归形式分治算法的基本思路（不用写出完整代码）

     1.   当 n=2 时，直接比较即可找到最大值和最小值

     2.   当 n>2 时，递归求出 $A[1..\frac{n}{2}]$ 和  $A[\frac{n}{2}..n]$ 中的最大元素和次大元素，分别标记为 $[x_1,y_1], [x_2,y_2]$，通过比较可以找出最大元素和次大元素

          ```python
          if x1 > x2:
              x = x1
              if x2 > y1:
                  y = x2
              else:
                  y = y1
          else:
              x = x2
              if y2 > x1:
                  y = y2
              else:
                  y = x1
          ```

2.   请给出算法中比较次数 $T(n)$ 满足的递归方程，并证明  $T(n) = \frac{3n}{2}-2$
     $$
     T(n) = 2T(\frac{n}{2}) + 2, T(2) = 1
     $$

     -   主定理
         $$
         a = 2, b = 2, f(n) = 2
         $$

         $$
         n^{log_b a} = O(f(n))
         $$

         $$
         T(n) = \Theta(n)
         $$

     -   展开
         $$
         \begin{align*}
         T(n) &= 2^2 T(\frac{n}{2^2}) + 2 + 2^2 \\ 
              &= 2^k T(\frac{n}{2^k}) + 2^1 + 2^2 + ... + 2^k \\ 
              &= 2^k T(\frac{n}{2^k}) + \frac{2 \cdot (2^k - 1)}{2 - 1} \\
         \end{align*}
         $$

         $$
         n = 2^{k+1}, k = log_2{\frac{n}{2}}
         $$

         $$
         \begin{align*}
         T(n) &= \frac{n}{2} + n - 2 \\ 
              &= \frac{3n}{2} - 2
         \end{align*}
         $$

### 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int INT_MIN = -1;

struct MaxVal {
    int max1;  // 最大值
    int max2;  // 第二大值
};

MaxVal findMaxTwo(const vector<int>& a, int l, int r) {
    if (l == r) {
        return {a[l], INT_MIN}; 
    }

    if (r - l == 1) {
        if (a[l] > a[r]) {
            return {a[l], a[r]};
        } else {
            return {a[r], a[l]};
        }
    }

    int m = (l + r) / 2;
    MaxVal left = findMaxTwo(a, l, m);
    MaxVal right = findMaxTwo(a, m + 1, r);

    vector<int> candidates = {left.max1, left.max2, right.max1, right.max2};
    sort(candidates.begin(), candidates.end(), greater<int>()); // 按降序排序
    return {candidates[0], candidates[1]};
}

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    MaxVal result = findMaxTwo(a, 0, n - 1);
    cout << "最大的数是: " << result.max1 << endl;
    cout << "第二大的数是: " << result.max2 << endl;
    return 0;
}
```

