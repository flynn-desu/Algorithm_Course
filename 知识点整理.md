# 一、算法分析基础知识 

## 记号

$$
f(n) = 10n^2 + 5n \\
g(n) = 2^n \\
$$

- $O$：**最坏情况**，函数复杂度小于等于
    $$
    f(n) = O(n^2) \\
    f(n) = O(f(n))
    $$

- $\Omega$：**最优情况**，复杂度大于等于

- $\Theta$：**精确情况**，复杂度等于

    当上界和下界相等时，用 $\Theta$ 来描述算法的复杂度

## 复杂度分析：主定理

### 公式

$$
T(n) = a T(\frac{n}{b}) + f(n), \quad a \geq 1, b > 1
$$

1. 若存在 $\epsilon > 0$，$f(n) = \Large O(n^{\log_b(a) - \epsilon})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)})$
2. 如果 $f(n) = \Large \Theta(n^{\log_b(a)})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)} \cdot \log(n))$
3. 若存在 $\epsilon > 0$，$f(n) = \Large \Omega(n^{\log_b(a) + \epsilon})$，并且存在常数 $c < 1$ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$，则 $T(n) = \Theta(f(n))$

### 分析

- 每个问题会分成 $a$ 个子问题
- 问题可以划分 $\Large log_b n$ 次，每次划分都伴随着 $f(n)$
- 对应到递归树中，最终叶子节点的复杂度是 $\Theta(1)$，共有 $\Large a^{log_b n}$ 个叶子节点，应用换底公式可得 $\Large a^{log_b n} = n^{log_b a}$
- 问题可以简化为 $T(n) = p f(n) + \Large n^{log_b a}$
- 求复杂度等价于比较**处理所有叶子节点**更耗时还是**处理所有划分**更耗时
- 第三种情况中为什么多了：存在常数 $ c < 1 $ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  
    - 每次划分后 $f(n)$ 并不会保持不变，而是会跟着划分 $\large af(\frac{n}{b})$
    - $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  要求 $f(n)$ 划分的复杂度不能大于问题本身，否则没必要分治

### 参考文献

- [深入浅出理解主定理原理(Master theorem)如何计算递归时间复杂度](https://blog.restkhz.com/post/how-master-theorem-works)
- [Wiki 主定理](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86)

## 例题：递归方程

某递归算法的时间复杂度 $T(n)$ 满足递归方程： $T(n) = 2T(n/2) + bn$ ($n \geq 2$) 且 $T(1) = a$，其中 $n = 2^k$，$a, b, k$ 均为正整数。$T(n)$ 可用 $\Theta$ 表示为

- 展开法
    $$
    \begin{align*}
    T(n) &= 2T\left(\frac{n}{2}\right) + bn \\
         &= 2\left(2T\left(\frac{n}{4}\right) + \frac{1}{2}bn\right) + bn \\
         &= 4T\left(\frac{n}{4}\right) + 2bn \\
         &= 2^k T\left(\frac{n}{2^k}\right) + kbn \\
    \end{align*}
    $$
    
    $$
    n = 2^k, k=log_2 n
    $$

    $$
    \begin{align*}
    T(n) &= 2^k T(1) + kbn \\
         &= an + bn \cdot \log n \\
         &= \Theta(n log n)
    \end{align*}
    $$
    
- 主定理
    $$
    a = 2, b = 2, f(n) = bn
    $$

    $$
    f(n) = \Theta(\large n^{log_b a}) = \Theta(n)
    $$

    $$
    T(n) = \Theta(n log n)
    $$

## 例题：冒泡排序

![image-20241211150958777](知识点整理.assets/image-20241211150958777.png)

设上述算法中元素比较的最多次数为 $T(n)$，则满足递归方程 $T(n) = T(n-1) + n -1$，$T(1) = T(0) = 0$
$$
\begin{align*}
T(n) &= T(n-1) + n - 1 \\
     &= T(n-2) + (n-2) + (n-1) \\
     &= T(n-3) + (n-3) + (n-2) + (n-1) \\
     &= T(n-k) + kn - \frac{k(k+1)}{2} \\
     &= T(1) + n(n-1) - \frac{n(n-1)}{2} \\
     &= \frac{1}{2} n(n-1) \\
     &= \Theta(n^2)
\end{align*}
$$

## 例题：图的 DFS

假设图 $G=\big <V, E \big >$ 用**邻接矩阵**表示， $n=|V|, m=|E|$。分析图的深度优先遍历算法 DFS 的时间复杂度。

1. 算法 DFS 中有哪些基本操作？各基本操作耗费时间是多少？

    算法 DFS 中基本操作包括：访问结点、访问相邻结点

    图中每个结点都恰好访问 1 次，访问结点的总次数为 n，耗费时间为 $\Theta(n)$；

    访问相邻节点即扫描邻接矩阵的一行，因此检测总耗费时间为 $\Theta(n^2)$

2. 请根据基本操作的耗费时间，分析得出算法 DFS 的时间复杂度。

    算法 DFS 的时间复杂度主要由访问结点的时间、访问相邻结点的时间来决定，其他运算耗费时间不超过这两部的耗费时间。

    故算法 DFS 时间复杂度为 $\Theta(n) + \Theta(n^2) = \Theta(n^2)$。

# 二、算法设计基本方法

## 例题：找到数组中最大的两个元素

假定 $n=2^k$（k 为正整数）。设计一个分治算法在数组 $A[1..n]$ 中找最大元素和第二大元素， 要求比较次数为 $\frac{3n}{2}-2$

### 分析

1.   用文字简要描述递归形式分治算法的基本思路（不用写出完整代码）

     1.   当 n=2 时，直接比较即可找到最大值和最小值

     2.   当 n>2 时，递归求出 $A[1..\frac{n}{2}]$ 和  $A[\frac{n}{2}..n]$ 中的最大元素和次大元素，分别标记为 $[x_1,y_1], [x_2,y_2]$，通过比较可以找出最大元素和次大元素

          ```python
          if x1 > x2:
              x = x1
              if x2 > y1:
                  y = x2
              else:
                  y = y1
          else:
              x = x2
              if y2 > x1:
                  y = y2
              else:
                  y = x1
          ```

2.   请给出算法中比较次数 $T(n)$ 满足的递归方程，并证明  $T(n) = \frac{3n}{2}-2$
     $$
     T(n) = 2T(\frac{n}{2}) + 2, T(2) = 1
     $$

     $+2$ 是因为 if 判断需进行两次
     
     - 主定理
         $$
         a = 2, b = 2, f(n) = 2
         $$
     
         $$
         n^{log_b a} = O(f(n))
         $$
     
         $$
         T(n) = \Theta(n)
         $$
     
         啊？只能给出数量级😭
     
     - 展开
         $$
         \begin{align*}
         T(n) &= 2^2 T(\frac{n}{2^2}) + 2 + 2^2 \\ 
              &= 2^k T(\frac{n}{2^k}) + 2^1 + 2^2 + ... + 2^k \\ 
              &= 2^k T(\frac{n}{2^k}) + \frac{2 \cdot (2^k - 1)}{2 - 1} \\
         \end{align*}
         $$

         $$
         n = 2^{k+1}, k = log_2{\frac{n}{2}}
         $$
     
         $$
         \begin{align*}
         T(n) &= \frac{n}{2} + n - 2 \\ 
              &= \frac{3n}{2} - 2
         \end{align*}
         $$

### 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int INT_MIN = -1;

struct MaxVal {
    int max1;  // 最大值
    int max2;  // 第二大值
};

MaxVal findMaxTwo(const vector<int>& a, int l, int r) {
    if (l == r) {
        return {a[l], INT_MIN}; 
    }

    if (r - l == 1) {
        if (a[l] > a[r]) {
            return {a[l], a[r]};
        } else {
            return {a[r], a[l]};
        }
    }

    int m = (l + r) / 2;
    MaxVal left = findMaxTwo(a, l, m);
    MaxVal right = findMaxTwo(a, m + 1, r);

    vector<int> candidates = {left.max1, left.max2, right.max1, right.max2};
    sort(candidates.begin(), candidates.end(), greater<int>()); // 按降序排序
    return {candidates[0], candidates[1]};
}

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    MaxVal result = findMaxTwo(a, 0, n - 1);
    cout << "最大的数是: " << result.max1 << endl;
    cout << "第二大的数是: " << result.max2 << endl;
    return 0;
}
```

## 例题：找出数组中最小的 t 个元素

![image-20241212192057238](知识点整理.assets/image-20241212192057238.png)

1. 使用 SELECT 函数找到最小元素 $x$
2. 使用 SELECT 函数找到第 t 小的元素 $y$
3. 扫描数组 A，将 $x \leq a[i] \leq y$ 的元素交换到 $A[1...t]$

调用两次 SELECT 的时间复杂度为 $\Theta(n)$，扫描数组并交换元素的时间复杂度为 $\Theta(n)$，因此算法的时间复杂度为 $\Theta(n)$

## 例题：Dijkstra

![image-20241212194241526](知识点整理.assets/image-20241212194241526.png)

### (1) Dijkstra 的基本思路

1. 准备一个 dist 数组，$dist[i]$ 表示起点到节点 i 的距离

2. 初始化 $dist[start]=0$，start 为起点编号，$dist[x] = \infty, x \neq start$
3. 查找 dist 中未处理过且距离最小的节点 x，遍历 x 的所有出边 $\big <x,y \big >$，y 是未处理过的节点
    1. 若 $dist[y] > dist[x] + |\big <x,y \big >|$，则更新距离
    2. 标记 x 已经处理

### (2) Dijkstra 处理负权图

不能，图中存在负权边

由于 $dist[a] < dist[b] < dist[c]$，且 a 没有出边，因此 b 的出边比 c 先更新，也先标记，而 c 到 b 的边是负权边 $dist[c] + (-4) = 5$ ，小于已经标记的 $dist[b] = 7$，却没有更新

### (3) Dijkstra 求最短路径过程

| 迭代节点 |  s   |  a   |  b   |  c   |  d   |  e   |
| -------- | :--: | :--: | :--: | :--: | :--: | :--: |
| s        |  0   |  2   |  10  |      |      |      |
| a        |      |      |      |  4   |  7   |      |
| c        |      |      |      |      |  6   |  7   |
| d        |      |      |  8   |      |      |      |
| e        |      |      |      |      |      |      |
| b        |      |      |      |      |      |      |
|          |  0   |  2   |  8   |  4   |  6   |  7   |

## 例题：最小生成树

![image-20241212204140138](知识点整理.assets/image-20241212204140138.png)

### （1）求解最小成本森林

- 对于不连通图

    - Prim 算法从某点开始依次在该点所在连通分支中加边，最终能得到**该连通分支**的最小生成树
    - Kruskal 算法按照边权由小到大依次考虑边的加入，能求得**所有连通分支**的最小生成树

    当图不连通时，需要在每个连通分支上单独运行 Prim 算法来处理。因此 Kruskal 算法更适合求解最小成本生成森林问题

### （2）求最小成本森林

![image-20241212204747572](知识点整理.assets/image-20241212204747572.png)

## 例题：最大间隔聚类

![image-20241212205200456](知识点整理.assets/image-20241212205200456.png)

- 最大间隔聚类问题可以用 Kruskal 算法解决

- Kruskal 算法

    1. 初始化 n 个连同分支，**对应 n 个聚类**

    2. 从小到大枚举所有边 e

        若加入 e 不会出现环，则加入 e，等价于**合并两个连通分支**

    3. 如果只剩下一个连通分支，停止（得到最小生成树）

- 如果修改 Kruskal 的终止条件：如果剩下 k 个连通分支，停止。则可以得到符合题意的 k 个非空子图

    由于 Kruskal 算法每次加入新边时都是考虑权值最小的边，因此，当得到 k 个连通分支时，**还未加入的 k-1 条边**中其实就是最小生成树中距离最大的 k-1 条边，因此，当去掉这最长的 k-1 条边时得到的这 k 个聚类的间隔也是最大的

    - 这里的 “还未加入的 k-1 条边” 是指还未加入最小生成树的 k-1 条边

        合并两个连同分支需要加入一条边，因此合并剩下的 k 个连同分支需要 k-1 条边

- 示例

    <img src="知识点整理.assets/image-20241212212042997.png" alt="image-20241212212042997"  />

{ACD} 和 {B} 的间隔是 4

## 例题：二部图

![image-20241212223050586](知识点整理.assets/image-20241212223050586.png)

### （1）文字描述算法思路

- 通过从某点开始对图进行 DFS 并依次给图中相邻节点分别着两种颜色（节点的“访问”即为节点的“着色”）

- 同一个节点不会重复着色

- 在此过程中如果存在有两个端点同色的**回边**，则该图不是二部图，否则该图是二部图

    - **回边**：在 DFS 过程中，发现的一个边，该边连接到当前节点的祖先节点

- 示例

    ![image-20241212224152162](知识点整理.assets/image-20241212224152162.png)

    - 左图

        假设从 A 开始 DFS
        $$
        A \to C \\
        A \to D \\
        B \to D
        $$
        着色过程中未出现回边同色，**左图是二部图**，其中 $V_1 = \{A,B\}, V_2 = \{C,D\}$

    - 右图

        假设从 A 开始 DFS
        $$
        A \to C \\
        A \to D \\
        A \to B \to D
        $$
        在 $A \to B \to D$ 中，遍历到 B 时，D 已经着色，且和 B 同色，而 $\big< B,D \big>$ 是一条回边，因此**右图不是二部图**

### （2）证明算法正确性

