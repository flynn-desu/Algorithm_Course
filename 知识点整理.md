# 1 算法分析的基本概念和方法

## 记号

$$
f(n) = 10n^2 + 5n \\
g(n) = 2^n \\
$$

- $O$：**最坏情况**，函数复杂度小于等于
    $$
    f(n) = O(n^2) \\
    f(n) = O(f(n))
    $$

- $\Omega$：**最优情况**，复杂度大于等于

- $\Theta$：**精确情况**，复杂度等于

    当上界和下界相等时，用 $\Theta$ 来描述算法的复杂度

## 复杂度分析：主定理

### 公式

$$
T(n) = a T(\frac{n}{b}) + f(n), \quad a \geq 1, b > 1
$$

1. 若存在 $\epsilon > 0$，$f(n) = \Large O(n^{\log_b(a) - \epsilon})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)})$
2. 如果 $f(n) = \Large \Theta(n^{\log_b(a)})$，那么 $T(n) = \Large \Theta(n^{\log_b(a)} \cdot \log(n))$
3. 若存在 $\epsilon > 0$，$f(n) = \Large \Omega(n^{\log_b(a) + \epsilon})$，并且存在常数 $c < 1$ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$，则 $T(n) = \Theta(f(n))$

### 分析

- 每个问题会分成 $a$ 个子问题
- 问题可以划分 $\Large log_b n$ 次，每次划分都伴随着 $f(n)$
- 对应到递归树中，最终叶子节点的复杂度是 $\Theta(1)$，共有 $\Large a^{log_b n}$ 个叶子节点，应用换底公式可得 $\Large a^{log_b n} = n^{log_b a}$
- 问题可以简化为 $T(n) = p f(n) + \Large n^{log_b a}$
- 求复杂度等价于比较**处理所有叶子节点**更耗时还是**处理所有划分**更耗时
- 第三种情况中为什么多了：存在常数 $ c < 1 $ 使得 $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  
    - 每次划分后 $f(n)$ 并不会保持不变，而是会跟着划分 $\large af(\frac{n}{b})$
    - $n \to \infty : \large af(\frac{n}{b}) \leq cf(n)$  要求 $f(n)$ 划分的复杂度不能大于问题本身，否则没必要分治

### 参考文献

- [深入浅出理解主定理原理(Master theorem)如何计算递归时间复杂度](https://blog.restkhz.com/post/how-master-theorem-works)
- [Wiki 主定理](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86)

## 复杂度分析：递归方程

某递归算法的时间复杂度 $T(n)$ 满足递归方程： $T(n) = 2T(n/2) + bn$ ($n \geq 2$) 且 $T(1) = a$，其中 $n = 2^k$，$a, b, k$ 均为正整数。$T(n)$ 可用 $\Theta$ 表示为

- 展开法
    $$
    \begin{align*}
    T(n) &= 2T\left(\frac{n}{2}\right) + bn \\
         &= 2\left(2T\left(\frac{n}{4}\right) + \frac{1}{2}bn\right) + bn \\
         &= 4T\left(\frac{n}{4}\right) + 2bn \\
         &= 2^k T\left(\frac{n}{2^k}\right) + kbn \\
    \end{align*}
    $$
    
    $$
    n = 2^k, k=log_2 n
    $$

    $$
    \begin{align*}
    T(n) &= 2^k T(1) + kbn \\
         &= an + bn \cdot \log n \\
         &= \Theta(n log n)
    \end{align*}
    $$
    
- 主定理
    $$
    a = 2, b = 2, f(n) = bn
    $$

    $$
    f(n) = \Theta(\large n^{log_b a}) = \Theta(n)
    $$

    $$
    T(n) = \Theta(n log n)
    $$

## 复杂度分析：代码段

![image-20241211150958777](知识点整理.assets/image-20241211150958777.png)

设上述算法中元素比较的最多次数为 $T(n)$，则满足递归方程 $T(n) = T(n-1) + n -1$，$T(1) = T(0) = 0$
$$
\begin{align*}
T(n) &= T(n-1) + n - 1 \\
     &= T(n-2) + (n-2) + (n-1) \\
     &= T(n-3) + (n-3) + (n-2) + (n-1) \\
     &= T(n-k) + kn - \frac{k(k+1)}{2} \\
     &= T(1) + n(n-1) - \frac{n(n-1)}{2} \\
     &= \frac{1}{2} n(n-1) \\
     &= \Theta(n^2)
\end{align*}
$$

## 复杂度分析：图的 DFS

假设图 $G=\big <V, E \big >$ 用**邻接矩阵**表示， $n=|V|, m=|E|$。分析图的深度优先遍历算法 DFS 的时间复杂度。

1. 算法 DFS 中有哪些基本操作？各基本操作耗费时间是多少？

    算法 DFS 中基本操作包括：访问结点、访问相邻结点

    图中每个结点都恰好访问 1 次，访问结点的总次数为 n，耗费时间为 $\Theta(n)$；

    访问相邻节点即扫描邻接矩阵的一行，因此检测总耗费时间为 $\Theta(n^2)$

2. 请根据基本操作的耗费时间，分析得出算法 DFS 的时间复杂度。

    算法 DFS 的时间复杂度主要由访问结点的时间、访问相邻结点的时间来决定，其他运算耗费时间不超过这两部的耗费时间。

    故算法 DFS 时间复杂度为 $\Theta(n) + \Theta(n^2) = \Theta(n^2)$。

